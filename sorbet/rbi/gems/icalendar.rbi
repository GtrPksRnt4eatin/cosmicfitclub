# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/icalendar/all/icalendar.rbi
#
# icalendar-2.5.0

module Icalendar
  def self.DowncasedHash(base); end
  def self.logger; end
  def self.logger=(logger); end
  def self.parse(source, single = nil); end
end
class Icalendar::Logger < SimpleDelegator
  def initialize(sink, level = nil); end
end
module Icalendar::HasProperties
  def append_custom_property(property_name, value); end
  def custom_property(property_name); end
  def initialize(*args); end
  def map_property_value(value, klass, multi_valued); end
  def method_missing(method, *args, &block); end
  def property(property_name); end
  def respond_to_missing?(method, include_private = nil); end
  def self.included(base); end
  def valid?(strict = nil); end
end
module Icalendar::HasProperties::ClassMethods
  def default_property_types; end
  def multi_property(prop, klass); end
  def multiple_properties; end
  def mutex_properties; end
  def mutually_exclusive_properties(*properties); end
  def optional_property(prop, klass = nil, suggested_single = nil); end
  def optional_single_property(prop, klass = nil); end
  def properties; end
  def required_multi_property(prop, klass = nil, validator = nil); end
  def required_properties; end
  def required_property(prop, klass = nil, validator = nil); end
  def single_properties; end
  def single_property(prop, klass); end
  def suggested_single_properties; end
end
module Icalendar::HasComponents
  def add_component(c); end
  def initialize(*args); end
  def method_missing(method, *args, &block); end
  def respond_to_missing?(method_name, include_private = nil); end
  def self.included(base); end
end
module Icalendar::HasComponents::ClassMethods
  def component(singular_name, find_by = nil, klass = nil); end
  def components; end
end
class Icalendar::Component
  def custom_components; end
  def custom_properties; end
  def ical_components; end
  def ical_fold(long_line, indent = nil); end
  def ical_name; end
  def ical_prop_name(prop_name); end
  def ical_properties; end
  def initialize(name, ical_name = nil); end
  def name; end
  def new_uid; end
  def parent; end
  def parent=(arg0); end
  def self.parse(source); end
  def to_ical; end
  extend Icalendar::HasComponents::ClassMethods
  extend Icalendar::HasProperties::ClassMethods
  include Icalendar::HasComponents
  include Icalendar::HasProperties
end
class Icalendar::DowncasedHash < SimpleDelegator
  def [](key); end
  def []=(key, value); end
  def delete(key, &block); end
  def has_key?(key); end
  def include?(key); end
  def initialize(base); end
  def member?(key); end
end
module Icalendar::Values
end
class Icalendar::Values::Array < Icalendar::Value
  def initialize(value, klass, params = nil, options = nil); end
  def needs_value_type?(default_type); end
  def params_ical; end
  def valid?; end
  def value_delimiter; end
  def value_ical; end
  def value_type; end
end
class Icalendar::Values::DateOrDateTime < Icalendar::Value
  def call; end
  def needs_value_type?(default_type); end
  def params_ical; end
  def parsed; end
  def value_ical; end
  def value_type; end
end
class Icalendar::Values::Binary < Icalendar::Value
  def base64?; end
  def params_ical; end
  def value_ical; end
end
class Icalendar::Values::Boolean < Icalendar::Value
  def initialize(value, params = nil); end
  def value_ical; end
end
class Icalendar::Values::Date < Icalendar::Value
  def <=>(other); end
  def initialize(value, params = nil); end
  def value_ical; end
end
class Icalendar::Values::Date::FormatError < ArgumentError
end
class Icalendar::TimezoneStore < SimpleDelegator
  def initialize; end
  def retrieve(tzid); end
  def self.instance; end
  def self.retrieve(tzid); end
  def self.store(timezone); end
  def store(timezone); end
end
class Icalendar::Values::ActiveSupportTimeWithZoneAdapter < ActiveSupport::TimeWithZone
end
module Icalendar::Values::TimeWithZone
  def initialize(value, params = nil); end
  def params_ical; end
  def tz_utc; end
end
class Icalendar::Values::DateTime < Icalendar::Value
  def <=>(other); end
  def initialize(value, params = nil); end
  def value_ical; end
  include Icalendar::Values::TimeWithZone
end
class Icalendar::Values::DateTime::FormatError < ArgumentError
end
class Icalendar::Values::Duration < Icalendar::Value
  def initialize(value, params = nil); end
  def parse_fields(value); end
  def past?; end
  def time?; end
  def value_ical; end
end
class Icalendar::Values::Float < Icalendar::Value
  def initialize(value, params = nil); end
  def value_ical; end
end
class Icalendar::Values::Integer < Icalendar::Value
  def initialize(value, params = nil); end
  def value_ical; end
end
class Icalendar::Values::Period < Icalendar::Value
  def duration; end
  def duration=(v); end
  def explicit_end; end
  def explicit_end=(v); end
  def initialize(value, params = nil); end
  def period_start; end
  def period_start=(v); end
  def value_ical; end
end
class Icalendar::Values::Recur < Icalendar::Value
  def initialize(value, params = nil); end
  def parse_fields(value); end
  def valid?; end
  def value_ical; end
end
class Icalendar::Values::Text < Icalendar::Value
  def initialize(value, params = nil); end
  def value_ical; end
end
class Icalendar::Values::Time < Icalendar::Value
  def initialize(value, params = nil); end
  def value_ical; end
  include Icalendar::Values::TimeWithZone
end
class Icalendar::Values::Uri < Icalendar::Value
  def initialize(value, params = nil); end
  def value_ical; end
end
class Icalendar::Values::UtcOffset < Icalendar::Value
  def behind?; end
  def initialize(value, params = nil); end
  def parse_fields(value); end
  def to_s; end
  def value_ical; end
  def zero_offset?; end
end
class Icalendar::Values::CalAddress < Icalendar::Values::Uri
end
class Icalendar::Value < SimpleDelegator
  def escape_param_value(value); end
  def ical_param(key, value); end
  def ical_params; end
  def ical_params=(arg0); end
  def initialize(value, params = nil); end
  def needs_value_type?(default_type); end
  def param_ical(name, param_value); end
  def params_ical; end
  def self.value_type; end
  def to_ical(default_type); end
  def value; end
  def value_type; end
end
class Icalendar::Alarm < Icalendar::Component
  def acknowledged; end
  def acknowledged=(value); end
  def action; end
  def action=(value); end
  def append_attach(value); end
  def append_attendee(value); end
  def attach; end
  def attach=(value); end
  def attendee; end
  def attendee=(value); end
  def description; end
  def description=(value); end
  def duration; end
  def duration=(value); end
  def initialize; end
  def repeat; end
  def repeat=(value); end
  def summary; end
  def summary=(value); end
  def trigger; end
  def trigger=(value); end
  def uid; end
  def uid=(value); end
  def valid?(strict = nil); end
end
class Icalendar::Event < Icalendar::Component
  def add_alarm(c); end
  def alarm(c = nil, &block); end
  def alarms; end
  def append_attach(value); end
  def append_attendee(value); end
  def append_categories(value); end
  def append_comment(value); end
  def append_contact(value); end
  def append_exdate(value); end
  def append_rdate(value); end
  def append_related_to(value); end
  def append_request_status(value); end
  def append_resources(value); end
  def append_rrule(value); end
  def attach; end
  def attach=(value); end
  def attendee; end
  def attendee=(value); end
  def categories; end
  def categories=(value); end
  def comment; end
  def comment=(value); end
  def contact; end
  def contact=(value); end
  def created; end
  def created=(value); end
  def description; end
  def description=(value); end
  def dtend; end
  def dtend=(value); end
  def dtstamp; end
  def dtstamp=(value); end
  def dtstart; end
  def dtstart=(value); end
  def duration; end
  def duration=(value); end
  def exdate; end
  def exdate=(value); end
  def geo; end
  def geo=(value); end
  def has_alarm?; end
  def initialize; end
  def ip_class; end
  def ip_class=(value); end
  def last_modified; end
  def last_modified=(value); end
  def location; end
  def location=(value); end
  def organizer; end
  def organizer=(value); end
  def priority; end
  def priority=(value); end
  def rdate; end
  def rdate=(value); end
  def recurrence_id; end
  def recurrence_id=(value); end
  def related_to; end
  def related_to=(value); end
  def request_status; end
  def request_status=(value); end
  def resources; end
  def resources=(value); end
  def rrule; end
  def rrule=(value); end
  def sequence; end
  def sequence=(value); end
  def status; end
  def status=(value); end
  def summary; end
  def summary=(value); end
  def transp; end
  def transp=(value); end
  def uid; end
  def uid=(value); end
  def url; end
  def url=(value); end
end
class Icalendar::Todo < Icalendar::Component
  def add_alarm(c); end
  def alarm(c = nil, &block); end
  def alarms; end
  def append_attach(value); end
  def append_attendee(value); end
  def append_categories(value); end
  def append_comment(value); end
  def append_contact(value); end
  def append_exdate(value); end
  def append_rdate(value); end
  def append_related_to(value); end
  def append_request_status(value); end
  def append_resources(value); end
  def append_rrule(value); end
  def attach; end
  def attach=(value); end
  def attendee; end
  def attendee=(value); end
  def categories; end
  def categories=(value); end
  def comment; end
  def comment=(value); end
  def completed; end
  def completed=(value); end
  def contact; end
  def contact=(value); end
  def created; end
  def created=(value); end
  def description; end
  def description=(value); end
  def dtstamp; end
  def dtstamp=(value); end
  def dtstart; end
  def dtstart=(value); end
  def due; end
  def due=(value); end
  def duration; end
  def duration=(value); end
  def exdate; end
  def exdate=(value); end
  def geo; end
  def geo=(value); end
  def has_alarm?; end
  def initialize; end
  def ip_class; end
  def ip_class=(value); end
  def last_modified; end
  def last_modified=(value); end
  def location; end
  def location=(value); end
  def organizer; end
  def organizer=(value); end
  def percent_complete; end
  def percent_complete=(value); end
  def priority; end
  def priority=(value); end
  def rdate; end
  def rdate=(value); end
  def recurrence_id; end
  def recurrence_id=(value); end
  def related_to; end
  def related_to=(value); end
  def request_status; end
  def request_status=(value); end
  def resources; end
  def resources=(value); end
  def rrule; end
  def rrule=(value); end
  def sequence; end
  def sequence=(value); end
  def status; end
  def status=(value); end
  def summary; end
  def summary=(value); end
  def uid; end
  def uid=(value); end
  def url; end
  def url=(value); end
end
class Icalendar::Journal < Icalendar::Component
  def append_attach(value); end
  def append_attendee(value); end
  def append_categories(value); end
  def append_comment(value); end
  def append_contact(value); end
  def append_description(value); end
  def append_exdate(value); end
  def append_rdate(value); end
  def append_related_to(value); end
  def append_request_status(value); end
  def append_rrule(value); end
  def attach; end
  def attach=(value); end
  def attendee; end
  def attendee=(value); end
  def categories; end
  def categories=(value); end
  def comment; end
  def comment=(value); end
  def contact; end
  def contact=(value); end
  def created; end
  def created=(value); end
  def description; end
  def description=(value); end
  def dtstamp; end
  def dtstamp=(value); end
  def dtstart; end
  def dtstart=(value); end
  def exdate; end
  def exdate=(value); end
  def initialize; end
  def ip_class; end
  def ip_class=(value); end
  def last_modified; end
  def last_modified=(value); end
  def organizer; end
  def organizer=(value); end
  def rdate; end
  def rdate=(value); end
  def recurrence_id; end
  def recurrence_id=(value); end
  def related_to; end
  def related_to=(value); end
  def request_status; end
  def request_status=(value); end
  def rrule; end
  def rrule=(value); end
  def sequence; end
  def sequence=(value); end
  def status; end
  def status=(value); end
  def summary; end
  def summary=(value); end
  def uid; end
  def uid=(value); end
  def url; end
  def url=(value); end
end
class Icalendar::Freebusy < Icalendar::Component
  def append_attendee(value); end
  def append_comment(value); end
  def append_freebusy(value); end
  def append_request_status(value); end
  def attendee; end
  def attendee=(value); end
  def comment; end
  def comment=(value); end
  def contact; end
  def contact=(value); end
  def dtend; end
  def dtend=(value); end
  def dtstamp; end
  def dtstamp=(value); end
  def dtstart; end
  def dtstart=(value); end
  def freebusy; end
  def freebusy=(value); end
  def initialize; end
  def organizer; end
  def organizer=(value); end
  def request_status; end
  def request_status=(value); end
  def uid; end
  def uid=(value); end
  def url; end
  def url=(value); end
end
class Icalendar::Timezone < Icalendar::Component
  def add_daylight(c); end
  def add_standard(c); end
  def daylight(c = nil, &block); end
  def daylight_for(local); end
  def daylights; end
  def has_daylight?; end
  def has_standard?; end
  def initialize; end
  def last_modified; end
  def last_modified=(value); end
  def offset_for_local(local); end
  def standard(c = nil, &block); end
  def standard_for(local); end
  def standards; end
  def tzid; end
  def tzid=(value); end
  def tzurl; end
  def tzurl=(value); end
  def valid?(strict = nil); end
end
module Icalendar::Timezone::TzProperties
  def self.included(base); end
end
class Icalendar::Timezone::Daylight < Icalendar::Component
  def append_comment(value); end
  def append_rdate(value); end
  def append_rrule(value); end
  def append_tzname(value); end
  def comment; end
  def comment=(value); end
  def dtstart; end
  def dtstart=(value); end
  def initialize; end
  def rdate; end
  def rdate=(value); end
  def rrule; end
  def rrule=(value); end
  def tzname; end
  def tzname=(value); end
  def tzoffsetfrom; end
  def tzoffsetfrom=(value); end
  def tzoffsetto; end
  def tzoffsetto=(value); end
  include Icalendar::Timezone::TzProperties
end
class Icalendar::Timezone::Standard < Icalendar::Component
  def append_comment(value); end
  def append_rdate(value); end
  def append_rrule(value); end
  def append_tzname(value); end
  def comment; end
  def comment=(value); end
  def dtstart; end
  def dtstart=(value); end
  def initialize; end
  def rdate; end
  def rdate=(value); end
  def rrule; end
  def rrule=(value); end
  def tzname; end
  def tzname=(value); end
  def tzoffsetfrom; end
  def tzoffsetfrom=(value); end
  def tzoffsetto; end
  def tzoffsetto=(value); end
  include Icalendar::Timezone::TzProperties
end
class Icalendar::Calendar < Icalendar::Component
  def add_event(c); end
  def add_freebusy(c); end
  def add_journal(c); end
  def add_timezone(c); end
  def add_todo(c); end
  def calscale; end
  def calscale=(value); end
  def event(c = nil, &block); end
  def events; end
  def find_event(id); end
  def find_freebusy(id); end
  def find_journal(id); end
  def find_timezone(id); end
  def find_todo(id); end
  def freebusy(c = nil, &block); end
  def freebusys; end
  def has_event?; end
  def has_freebusy?; end
  def has_journal?; end
  def has_timezone?; end
  def has_todo?; end
  def initialize; end
  def ip_method; end
  def ip_method=(value); end
  def journal(c = nil, &block); end
  def journals; end
  def prodid; end
  def prodid=(value); end
  def publish; end
  def timezone(c = nil, &block); end
  def timezones; end
  def todo(c = nil, &block); end
  def todos; end
  def version; end
  def version=(value); end
end
class Icalendar::Parser
  def component_class; end
  def component_class=(arg0); end
  def get_wrapper_class(component, fields); end
  def initialize(source, strict = nil); end
  def next_fields; end
  def parse; end
  def parse_component(component); end
  def parse_fields(input); end
  def parse_property(component, fields = nil); end
  def read_in_data; end
  def source; end
  def strict; end
  def strict?; end
  def wrap_in_array?(klass, value, multi_property); end
  def wrap_property_value(component, fields, multi_property); end
end
