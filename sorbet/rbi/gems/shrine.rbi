# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/shrine/all/shrine.rbi
#
# shrine-2.9.0

class Shrine
  def self.version; end
  extend Shrine::Plugins::Base::ClassMethods
  extend Shrine::Plugins::Base::ClassMethods
  include Shrine::Plugins::Base::InstanceMethods
end
module Shrine::VERSION
end
class Shrine::Error < StandardError
end
class Shrine::InvalidFile < Shrine::Error
  def initialize(io, missing_methods); end
  def message; end
  def missing_methods_string; end
end
class Shrine::UploadedFile
  extend Shrine::Plugins::Base::FileClassMethods
  include Shrine::Plugins::Base::FileMethods
end
class Shrine::Attachment < Module
  extend Shrine::Plugins::Base::AttachmentClassMethods
  include Shrine::Plugins::Base::AttachmentMethods
end
class Shrine::Attacher
  extend Shrine::Plugins::Base::AttacherClassMethods
  include Shrine::Plugins::Base::AttacherMethods
end
module Shrine::Plugins
  def self.load_plugin(name); end
  def self.register_plugin(name, mod); end
end
module Shrine::Plugins::Base
end
module Shrine::Plugins::Base::ClassMethods
  def [](name, *args); end
  def attachment(name, *args); end
  def deprecation(message); end
  def find_storage(name); end
  def inherited(subclass); end
  def opts; end
  def plugin(plugin, *args, &block); end
  def storages; end
  def storages=(arg0); end
  def uploaded_file(object, &block); end
end
module Shrine::Plugins::Base::InstanceMethods
  def _delete(uploaded_file, context); end
  def _enforce_io(io); end
  def _store(io, context); end
  def copy(io, context); end
  def delete(uploaded_file, context = nil); end
  def extract_filename(io); end
  def extract_metadata(io, context = nil); end
  def extract_mime_type(io); end
  def extract_size(io); end
  def generate_location(io, context = nil); end
  def generate_uid(io); end
  def get_location(io, context); end
  def get_metadata(io, context); end
  def initialize(storage_key); end
  def opts; end
  def process(io, context = nil); end
  def processed(io, context); end
  def put(io, context); end
  def remove(uploaded_file, context); end
  def storage; end
  def storage_key; end
  def store(io, context = nil); end
  def upload(io, context = nil); end
  def uploaded?(uploaded_file); end
end
module Shrine::Plugins::Base::AttachmentClassMethods
  def inspect; end
  def shrine_class; end
  def shrine_class=(arg0); end
end
module Shrine::Plugins::Base::AttachmentMethods
  def attachment_name; end
  def initialize(name, **options); end
  def inspect; end
  def options; end
  def shrine_class; end
  def to_s; end
end
module Shrine::Plugins::Base::AttacherClassMethods
  def inspect; end
  def shrine_class; end
  def shrine_class=(arg0); end
  def validate(&block); end
end
module Shrine::Plugins::Base::AttacherMethods
  def _delete(uploaded_file, **options); end
  def _equalize_phase_and_action(options); end
  def _promote(uploaded_file = nil, **options); end
  def _set(uploaded_file); end
  def assign(value); end
  def assign_cached(cached_file); end
  def attached?; end
  def cache!(io, **options); end
  def cache; end
  def cached?; end
  def changed?; end
  def context; end
  def convert_after_read(value); end
  def convert_before_write(value); end
  def convert_to_data(uploaded_file); end
  def data_attribute; end
  def delete!(uploaded_file, **options); end
  def destroy; end
  def errors; end
  def finalize; end
  def get; end
  def initialize(record, name, cache: nil, store: nil); end
  def name; end
  def promote(uploaded_file = nil, **options); end
  def read; end
  def record; end
  def replace; end
  def save; end
  def set(uploaded_file); end
  def shrine_class; end
  def store!(io, **options); end
  def store; end
  def stored?; end
  def swap(uploaded_file); end
  def update(uploaded_file); end
  def uploaded_file(object, &block); end
  def url(**options); end
  def validate; end
  def validate_block; end
  def write(value); end
end
module Shrine::Plugins::Base::FileClassMethods
  def inspect; end
  def shrine_class; end
  def shrine_class=(arg0); end
end
module Shrine::Plugins::Base::FileMethods
  def ==(other); end
  def as_json(*args); end
  def close; end
  def content_type; end
  def data; end
  def delete; end
  def download(*args); end
  def eof?; end
  def eql?(other); end
  def exists?; end
  def extension; end
  def hash; end
  def id; end
  def initialize(data); end
  def io; end
  def metadata; end
  def mime_type; end
  def open(*args); end
  def original_filename; end
  def read(*args); end
  def replace(io, context = nil); end
  def rewind; end
  def shrine_class; end
  def size; end
  def storage; end
  def storage_key; end
  def to_io; end
  def to_json(*args); end
  def uploader; end
  def url(**options); end
end
module Shrine::Storage
end
class Shrine::Storage::S3
  def bucket; end
  def clear!(&block); end
  def client; end
  def copy(io, id, **options); end
  def copyable?(io); end
  def delete(id); end
  def delete_objects(objects); end
  def download(id, **options); end
  def encode_content_disposition(content_disposition); end
  def exists?(id); end
  def host; end
  def initialize(bucket:, prefix: nil, host: nil, upload_options: nil, multipart_threshold: nil, **s3_options); end
  def method_missing(name, *args); end
  def object(id); end
  def open(id, **options); end
  def prefix; end
  def presign(id, **options); end
  def put(io, id, **options); end
  def s3; end
  def upload(io, id, shrine_metadata: nil, **upload_options); end
  def upload_options; end
  def url(id, download: nil, public: nil, host: nil, **options); end
end
