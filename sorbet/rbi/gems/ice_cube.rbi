# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ice_cube/all/ice_cube.rbi
#
# ice_cube-0.16.3

module IceCube
  def self.compatibility; end
  def self.compatibility=(version); end
  def self.to_s_time_format; end
  def self.to_s_time_format=(format); end
end
module IceCube::Deprecated
  def deprecated(name, replacement); end
  def deprecated_alias(name, replacement); end
  def self.schedule_options(schedule, options); end
end
module IceCube::Validations
end
class IceCube::InputAlignment
  def fixed_validations; end
  def initialize(rule, value, rule_part); end
  def interval_validation; end
  def interval_value; end
  def rule; end
  def rule_part; end
  def value; end
  def verify(freq, options = nil, &block); end
  def verify_freq_alignment(freq); end
  def verify_month_alignment(_freq); end
  def verify_wday_alignment(freq); end
end
class IceCube::Rule
  def ==(other); end
  def hash; end
  def next_time(time, schedule, closing_time); end
  def on?(time, schedule); end
  def reset; end
  def self.apply_validation(rule, name, args); end
  def self.daily(interval = nil); end
  def self.from_hash(original_hash); end
  def self.from_ical(ical); end
  def self.from_yaml(yaml); end
  def self.hourly(interval = nil); end
  def self.minutely(interval = nil); end
  def self.monthly(interval = nil); end
  def self.secondly(interval = nil); end
  def self.weekly(interval = nil, week_start = nil); end
  def self.yearly(interval = nil); end
  def terminating?; end
  def to_hash; end
  def to_ical; end
  def to_yaml(*args); end
  def uses; end
end
class IceCube::Validations::FixedValue
  def starting_unit(start_time); end
  def validate(time, start_time); end
  def validate_day_lock(time, start_time); end
  def validate_hour_lock(time, start_time); end
  def validate_interval_lock(time, start_time); end
end
module IceCube::Validations::ScheduleLock
  def schedule_lock(*types); end
end
class IceCube::Validations::ScheduleLock::Validation < IceCube::Validations::FixedValue
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(type); end
  def key; end
  def type; end
  def value; end
end
class IceCube::StringBuilder
  def base=(arg0); end
  def initialize; end
  def piece(type, prefix = nil, suffix = nil); end
  def self.formatter(type); end
  def self.register_formatter(type, &formatter); end
  def to_s; end
  extend IceCube::StringBuilder::Helpers
end
module IceCube::StringBuilder::Helpers
  def literal_ordinal(number); end
  def nice_number(number); end
  def ordinal(number); end
  def ordinalize(number); end
  def sentence(array); end
end
module IceCube::Validations::Count
  def count(max); end
  def occurrence_count; end
end
class IceCube::Validations::Count::Validation
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def count; end
  def dst_adjust?; end
  def initialize(count, rule); end
  def rule; end
  def type; end
  def validate(time, start_time); end
end
module IceCube::Validations::Until
  def until(time); end
  def until_date(*args, &block); end
  def until_time; end
  extend IceCube::Deprecated
end
class IceCube::Validations::Until::Validation
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(time); end
  def time; end
  def type; end
  def validate(step_time, start_time); end
end
class IceCube::ValidatedRule < IceCube::Rule
  def base_interval_validation; end
  def clobber_base_validations(*types); end
  def find_acceptable_time_before(boundary); end
  def finds_acceptable_time?; end
  def full_required?; end
  def initialize(interval = nil); end
  def next_time(time, start_time, closing_time); end
  def normalized_interval(interval); end
  def other_interval_validations; end
  def past_closing_time?(closing_time); end
  def realign(opening_time, start_time); end
  def replace_validations_for(key, arr); end
  def reset; end
  def shift_time_by_validation(res, validation); end
  def to_hash; end
  def to_ical; end
  def to_s; end
  def validation_accepts_or_updates_time?(validations_for_type); end
  def validation_names; end
  def validations; end
  def validations_for(key); end
  def verify_alignment(value, freq, rule_part); end
  include IceCube::Validations::Count
  include IceCube::Validations::ScheduleLock
  include IceCube::Validations::Until
end
module IceCube::Validations::HourOfDay
  def hour_of_day(*hours); end
  def realign(opening_time, start_time); end
end
class IceCube::Validations::HourOfDay::Validation < IceCube::Validations::FixedValue
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def hour; end
  def initialize(hour); end
  def key; end
  def type; end
  def value; end
end
module IceCube::Validations::MinuteOfHour
  def minute_of_hour(*minutes); end
  def realign(opening_time, start_time); end
end
class IceCube::Validations::MinuteOfHour::Validation < IceCube::Validations::FixedValue
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(minute); end
  def key; end
  def minute; end
  def type; end
  def value; end
end
module IceCube::Validations::SecondOfMinute
  def realign(opening_time, start_time); end
  def second_of_minute(*seconds); end
end
class IceCube::Validations::SecondOfMinute::Validation < IceCube::Validations::FixedValue
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(second); end
  def key; end
  def second; end
  def type; end
  def value; end
end
module IceCube::Validations::DayOfMonth
  def day_of_month(*days); end
end
class IceCube::Validations::DayOfMonth::Validation < IceCube::Validations::FixedValue
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def day; end
  def dst_adjust?; end
  def initialize(day); end
  def key; end
  def type; end
  def value; end
end
module IceCube::Validations::DayOfWeek
  def day_of_week(dows); end
end
class IceCube::Validations::DayOfWeek::Validation
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def day; end
  def dst_adjust?; end
  def initialize(day, occ); end
  def occ; end
  def type; end
  def validate(step_time, start_time); end
end
module IceCube::Validations::Day
  def day(*days); end
end
class IceCube::Validations::Day::Validation < IceCube::Validations::FixedValue
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def day; end
  def dst_adjust?; end
  def initialize(day); end
  def key; end
  def type; end
  def value; end
end
module IceCube::Validations::MonthOfYear
  def month_of_year(*months); end
end
class IceCube::Validations::MonthOfYear::Validation < IceCube::Validations::FixedValue
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(month); end
  def key; end
  def month; end
  def type; end
  def value; end
end
module IceCube::Validations::DailyInterval
  def interval(interval); end
end
class IceCube::Validations::DailyInterval::Validation
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(interval); end
  def interval; end
  def type; end
  def validate(step_time, start_time); end
end
class IceCube::DailyRule < IceCube::ValidatedRule
  def initialize(interval = nil); end
  include IceCube::Validations::DailyInterval
  include IceCube::Validations::Day
  include IceCube::Validations::DayOfMonth
  include IceCube::Validations::DayOfWeek
  include IceCube::Validations::HourOfDay
  include IceCube::Validations::MinuteOfHour
  include IceCube::Validations::MonthOfYear
  include IceCube::Validations::SecondOfMinute
end
module IceCube::Validations::MonthlyInterval
  def interval(interval); end
end
class IceCube::Validations::MonthlyInterval::Validation
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(interval); end
  def interval; end
  def type; end
  def validate(step_time, start_time); end
end
class IceCube::MonthlyRule < IceCube::ValidatedRule
  def initialize(interval = nil); end
  include IceCube::Validations::Day
  include IceCube::Validations::DayOfMonth
  include IceCube::Validations::DayOfWeek
  include IceCube::Validations::HourOfDay
  include IceCube::Validations::MinuteOfHour
  include IceCube::Validations::MonthOfYear
  include IceCube::Validations::MonthlyInterval
  include IceCube::Validations::SecondOfMinute
end
module IceCube::Validations::WeeklyInterval
  def interval(interval, week_start = nil); end
end
class IceCube::Validations::WeeklyInterval::Validation
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(interval, week_start); end
  def interval; end
  def type; end
  def validate(step_time, start_time); end
  def week_start; end
end
class IceCube::WeeklyRule < IceCube::ValidatedRule
  def initialize(interval = nil, week_start = nil); end
  def realign(step_time, start_time); end
  def wday_offset(step_time, start_time); end
  def week_start; end
  include IceCube::Validations::Day
  include IceCube::Validations::DayOfWeek
  include IceCube::Validations::HourOfDay
  include IceCube::Validations::MinuteOfHour
  include IceCube::Validations::MonthOfYear
  include IceCube::Validations::SecondOfMinute
  include IceCube::Validations::WeeklyInterval
end
module IceCube::Validations::DayOfYear
  def day_of_year(*days); end
end
class IceCube::Validations::DayOfYear::Validation
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def day; end
  def dst_adjust?; end
  def initialize(day); end
  def type; end
  def validate(step_time, start_time); end
end
module IceCube::Validations::YearlyInterval
  def interval(interval); end
end
class IceCube::Validations::YearlyInterval::Validation
  def build_hash(builder); end
  def build_ical(builder); end
  def build_s(builder); end
  def dst_adjust?; end
  def initialize(interval); end
  def interval; end
  def type; end
  def validate(step_time, start_time); end
end
class IceCube::YearlyRule < IceCube::ValidatedRule
  def initialize(interval = nil); end
  include IceCube::Validations::Day
  include IceCube::Validations::DayOfMonth
  include IceCube::Validations::DayOfWeek
  include IceCube::Validations::DayOfYear
  include IceCube::Validations::HourOfDay
  include IceCube::Validations::MinuteOfHour
  include IceCube::Validations::MonthOfYear
  include IceCube::Validations::SecondOfMinute
  include IceCube::Validations::YearlyInterval
end
class IceCube::Schedule
  def ==(other); end
  def add_exception_date(*args, &block); end
  def add_exception_rule(rule); end
  def add_exception_time(time); end
  def add_recurrence_date(*args, &block); end
  def add_recurrence_rule(rule); end
  def add_recurrence_time(time); end
  def all_occurrences; end
  def all_occurrences_enumerator; end
  def conflicts_with?(other_schedule, closing_time = nil); end
  def duration; end
  def duration=(seconds); end
  def each_occurrence(&block); end
  def encode_with(coder); end
  def end_date(*args, &block); end
  def end_date=(*args, &block); end
  def end_time; end
  def end_time=(end_time); end
  def enumerate_occurrences(opening_time, closing_time = nil, options = nil); end
  def eql?(other); end
  def exception_dates(*args, &block); end
  def exception_rules; end
  def exception_time?(time); end
  def exception_times; end
  def exdate(*args, &block); end
  def exdates(*args, &block); end
  def exrule(rule); end
  def exrules; end
  def extime(time); end
  def extimes; end
  def first(n = nil); end
  def full_required?; end
  def hash; end
  def implicit_start_occurrence_rule; end
  def initialize(start_time = nil, options = nil); end
  def last(n = nil); end
  def next_occurrence(from = nil, options = nil); end
  def next_occurrences(num, from = nil, options = nil); end
  def next_time(time, closing_time); end
  def occurrences(closing_time); end
  def occurrences_between(begin_time, closing_time, options = nil); end
  def occurring_at?(time); end
  def occurring_between?(opening_time, closing_time); end
  def occurs_at?(time); end
  def occurs_between?(begin_time, closing_time, options = nil); end
  def occurs_on?(date); end
  def previous_occurrence(from); end
  def previous_occurrences(num, from); end
  def rdate(*args, &block); end
  def rdates(*args, &block); end
  def recurrence_dates(*args, &block); end
  def recurrence_rules; end
  def recurrence_rules_with_implicit_start_occurrence; end
  def recurrence_times; end
  def recurrence_times_with_start_time; end
  def recurrence_times_without_start_time; end
  def remaining_occurrences(from = nil, options = nil); end
  def remaining_occurrences_enumerator(from = nil, options = nil); end
  def remove_exception_date(*args, &block); end
  def remove_exception_rule(rule); end
  def remove_exception_time(time); end
  def remove_exdate(*args, &block); end
  def remove_extime(time); end
  def remove_rdate(*args, &block); end
  def remove_recurrence_date(*args, &block); end
  def remove_recurrence_rule(rule); end
  def remove_recurrence_time(time); end
  def remove_rtime(time); end
  def require_terminating_rules; end
  def reset; end
  def rrule(rule); end
  def rrules; end
  def rtime(time); end
  def rtimes; end
  def self.dump(schedule); end
  def self.from_hash(original_hash, options = nil); end
  def self.from_ical(ical, options = nil); end
  def self.from_yaml(yaml, options = nil); end
  def self.load(yaml); end
  def start_date(*args, &block); end
  def start_date=(*args, &block); end
  def start_time; end
  def start_time=(start_time); end
  def terminating?; end
  def to_h; end
  def to_hash; end
  def to_ical(force_utc = nil); end
  def to_s; end
  extend IceCube::Deprecated
end
